<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>3</title>
    <link href="/2020/08/12/3/"/>
    <url>/2020/08/12/3/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ijkplayer 常用参数，首播启动优化</title>
    <link href="/2020/08/12/2/"/>
    <url>/2020/08/12/2/</url>
    
    <content type="html"><![CDATA[<h2 id="延时高问题分析"><a href="#延时高问题分析" class="headerlink" title="延时高问题分析"></a><center>延时高问题分析</center></h2><p>可能产生延时的模块有哪些：</p><ol><li>图像处理延时，比如画面剪裁、美颜、特效处理</li><li>视频编码/解码延时</li><li>网络传输的延时</li><li>业务代码中的缓冲区</li></ol><p>一般图像处理、数据拷贝、编解码带来的延时，都是 ms 级别的，真正会产生比较大延时的地方，一个是互联网上的网络传输延时，另一个就是业务代码中的缓冲区了。</p><h2 id="协议延时"><a href="#协议延时" class="headerlink" title="协议延时"></a><center>协议延时</center></h2><p>通常标准的直播协议有 RTMP，HLV，HLS 三种，一般 RTMP/HLV 协议的延时在 1～3s，HLS 协议的直播延时则会更大，注重延时的直播应用，大都会选择 RTMP/HLV 协议，这些协议均是基于 tcp 的协议，tcp 协议的多个特性导致其延时明显要高于基于 udp 的私有协议，主要有如下方面：</p><p>建立连接的三次握手<br>ACK 机制<br>丢包重传</p><p>因此，如果想从本质上解决直播延时问题，还是要换成基于 udp 的私有协议来传输数据。</p><h2 id="RTMP和RTSP的区别和适用范围"><a href="#RTMP和RTSP的区别和适用范围" class="headerlink" title="RTMP和RTSP的区别和适用范围"></a><center>RTMP和RTSP的区别和适用范围</center></h2><p>从网络上接收视频时首先要解协议（RTSP/RTMP/HTTP），然后是解格式（MKV，RMVB），之后才是将视频（H264）和音频（AAC）格式数据分别解码为图像（RGB/YUV）和声音（PCM），再根据时间戳同步播放。 </p><p>RTSP+RTP主要用于IPTV，原因是传输数据使用的是UDP，在网络环境比较稳定的情况下，传输效率是比较高的； </p><p>RTMP主要用于互联网音视频传输，它使用的是TCP传输，因为互联网环境相对较差，采用RTMP保证了视频的传输质量，但是其传输延迟相对较高，传输效率相对较低。 </p><p>librtmp是RTMP协议的实现，可以使用librtmp来实现协议的解析和数据的收发。直播服务器可以基于nginx+rtmp实现；直播客户端方面采用librtmp负责推流，FFmpeg负责编码；收看客户端采用VLC即可，因为VLC本身既可以解析RTMP流，又可以解析编码后的视频数据。</p><h2 id="ijkplayer-参数"><a href="#ijkplayer-参数" class="headerlink" title="ijkplayer 参数"></a><center>ijkplayer 参数</center></h2><pre><code class="hljs groovy"><span class="hljs-comment">// 拉流 URL</span>NSURL *liveURL = [NSURL <span class="hljs-string">URLWithString:</span>_live.stream_addr];<span class="hljs-comment">// 获取默认配置</span>IJKFFOptions *options = [IJKFFOptions optionsByDefault];<span class="hljs-comment">// 如果是rtsp协议，可以优先用tcp(默认是用udp)</span>[options <span class="hljs-string">setFormatOptionValue:</span>@<span class="hljs-string">"tcp"</span> <span class="hljs-string">forKey:</span>@<span class="hljs-string">"rtsp_transport"</span>];<span class="hljs-comment">// 帧速率（fps）可以改，确认非标准帧率会导致音画不同步，所以只能设定为15或者29.97）</span>[options <span class="hljs-string">setPlayerOptionIntValue:</span><span class="hljs-number">29.97</span> <span class="hljs-string">forKey:</span>@<span class="hljs-string">"r"</span>]; <span class="hljs-comment">// 跳帧开关</span>[options <span class="hljs-string">setPlayerOptionIntValue:</span><span class="hljs-number">0</span> <span class="hljs-string">forKey:</span>@<span class="hljs-string">"framedrop"</span>]; <span class="hljs-comment">// 开启硬编码 （默认是 0 ：软解）（硬件解码CPU消耗低。软解，更稳定）</span>[options <span class="hljs-string">setPlayerOptionIntValue:</span><span class="hljs-number">1</span> <span class="hljs-string">forKey:</span>@<span class="hljs-string">"videotoolbox"</span>]; <span class="hljs-comment">// 重连开启 BOOL</span>[options <span class="hljs-string">setFormatOptionIntValue:</span><span class="hljs-number">1</span> <span class="hljs-string">forKey:</span>@<span class="hljs-string">"reconnect"</span>]; <span class="hljs-comment">// 超时时间，timeout参数只对http设置有效，若果你用rtmp设置timeout，ijkplayer内部会忽略timeout参数。</span><span class="hljs-comment">// rtmp的timeout参数含义和http的不一样。</span>[options <span class="hljs-string">setFormatOptionIntValue:</span><span class="hljs-number">30</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span> <span class="hljs-string">forKey:</span>@<span class="hljs-string">"timeout"</span>]; <span class="hljs-comment">// ① 开启环路滤波（0比48清楚，但解码开销大，48基本没有开启环路滤波，清晰度低，解码开销小）①</span>[options <span class="hljs-string">setCodecOptionIntValue:</span>IJK_AVDISCARD_ALL <span class="hljs-string">forKey:</span>@<span class="hljs-string">"skip_loop_filter"</span>];<span class="hljs-comment">// 最大缓存大小是3秒，可以依据自己的需求修改</span>[options <span class="hljs-string">setPlayerOptionIntValue:</span><span class="hljs-number">1000</span> <span class="hljs-string">forKey:</span>@<span class="hljs-string">"max_cached_duration"</span>];<span class="hljs-comment">// 关闭播放器缓冲</span>[options <span class="hljs-string">setPlayerOptionIntValue:</span><span class="hljs-number">0</span> <span class="hljs-string">forKey:</span>@<span class="hljs-string">"packet-buffering"</span>];<span class="hljs-comment">// 解码参数，画面更清晰</span>[options <span class="hljs-string">setCodecOptionIntValue:</span>IJK_AVDISCARD_DEFAULT <span class="hljs-string">forKey:</span>@<span class="hljs-string">"skip_loop_filter"</span>];<span class="hljs-comment">// 底下这几句补上，可以大大提高ijkplayer打开直播流的速度</span>[options <span class="hljs-string">setOptionIntValue:</span><span class="hljs-number">100</span>L <span class="hljs-string">forKey:</span>@<span class="hljs-string">"analyzemaxduration"</span> <span class="hljs-string">ofCategory:</span><span class="hljs-number">1</span>];<span class="hljs-comment">// 播放前的探测size，默认是1M, 改小一点会出画面更快</span>[options <span class="hljs-string">setOptionIntValue:</span><span class="hljs-number">10240</span>L <span class="hljs-string">forKey:</span>@<span class="hljs-string">"probesize"</span> <span class="hljs-string">ofCategory:</span><span class="hljs-number">1</span>];<span class="hljs-comment">// 每处理一个packet之后刷新io上下文</span>[options <span class="hljs-string">setOptionIntValue:</span><span class="hljs-number">1</span>L <span class="hljs-string">forKey:</span>@<span class="hljs-string">"flush_packets"</span> <span class="hljs-string">ofCategory:</span><span class="hljs-number">1</span>];[options <span class="hljs-string">setOptionIntValue:</span><span class="hljs-number">0</span>L <span class="hljs-string">forKey:</span>@<span class="hljs-string">"packet-buffering"</span> <span class="hljs-string">ofCategory:</span><span class="hljs-number">4</span>];[options <span class="hljs-string">setOptionIntValue:</span><span class="hljs-number">1</span>L <span class="hljs-string">forKey:</span>@<span class="hljs-string">"framedrop"</span> <span class="hljs-string">ofCategory:</span><span class="hljs-number">4</span>];</code></pre><p>IJKFFMoviePlayerController *playerController = [[IJKFFMoviePlayerController alloc] initWithContentURL:liveURL withOptions:options];</p><pre><code class="hljs angelscript">① <span class="hljs-comment">// for codec option 'skip_loop_filter' and 'skip_frame'</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> IJKAVDiscard &#123;    <span class="hljs-comment">/* We leave some space between them for extensions (drop some</span><span class="hljs-comment">     * keyframes for intra-only or drop just some bidir frames). */</span>    IJK_AVDISCARD_NONE    =<span class="hljs-number">-16</span>, <span class="hljs-comment">///&lt; discard nothing</span>    IJK_AVDISCARD_DEFAULT =  <span class="hljs-number">0</span>, <span class="hljs-comment">///&lt; discard useless packets like 0 size packets in avi</span>    IJK_AVDISCARD_NONREF  =  <span class="hljs-number">8</span>, <span class="hljs-comment">///&lt; discard all non reference</span>    IJK_AVDISCARD_BIDIR   = <span class="hljs-number">16</span>, <span class="hljs-comment">///&lt; discard all bidirectional frames</span>    IJK_AVDISCARD_NONKEY  = <span class="hljs-number">32</span>, <span class="hljs-comment">///&lt; discard all frames except keyframes</span>    IJK_AVDISCARD_ALL     = <span class="hljs-number">48</span>, <span class="hljs-comment">///&lt; discard all</span>&#125; IJKAVDiscard;</code></pre><p>最后附上打包好的 <a href="https://github.com/imWalsh/ijkplayer-framework.framework" target="_blank" rel="noopener">ijkplayer-framwork</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ijkplayer</tag>
      
      <tag>直播</tag>
      
      <tag>起播</tag>
      
      <tag>优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[TableView] Warning once only: UITableViewAlertForLayoutOutsideViewHierarchy</title>
    <link href="/2020/06/18/1/"/>
    <url>/2020/06/18/1/</url>
    
    <content type="html"><![CDATA[<p>在 viewDidLoad 用 RxSwift 对 TableView 做数据绑定的时候触发的警告</p><blockquote><p>[TableView] Warning once only: UITableView was told to layout its visible cells and other contents without being in the view hierarchy (the table view or one of its superviews has not been added to a window).This may cause bugs by forcing views inside the table view to load and perform layout without accurate information (e.g. table view bounds, trait collection, layout margins, safe area insets, etc), and will also cause unnecessary performance overhead due to extra layout passes. Make a symbolic breakpoint at UITableViewAlertForLayoutOutsideViewHierarchy to catch this in the debugger and see what caused this to occur, so you can avoid this action altogether if possible, or defer it until the table view has been added to a window. Table view: &lt;UITableView: 0x128815a00; frame = (0 27; 414 896); clipsToBounds = YES; autoresize = RM+BM; gestureRecognizers = &lt;NSArray: 0x283f52070&gt;; layer = &lt;CALayer: 0x283155000&gt;; contentOffset: {0, 0}; contentSize: {414, 0}; adjustedContentInset: {0, 0, 0, 0}; dataSource: &lt;RxCocoa.RxTableViewDataSourceProxy: 0x281554ea0&gt;&gt;</p></blockquote><p>大概原因就是</p><p><code>the table view or one of its superviews has not been added to a window</code></p><p>视图没有被添加到Window上，导致视图层级结构警告</p><p><strong>解决方法：</strong></p><p>提示：</p><p><code>so you can avoid this action altogether if possible, or defer it until the table view has been added to a window.</code></p><ul><li>异步</li></ul><pre><code class="hljs roboconf">DispatchQueue.main.async &#123; [<span class="hljs-attribute">unowned self] in</span><span class="hljs-attribute">    self.vm.data.bind(to</span>: self<span class="hljs-variable">.tableView</span><span class="hljs-variable">.rx</span><span class="hljs-variable">.items</span>(cellIdentifier: "MyCell")) &#123; idx, model, cell in        cell<span class="hljs-variable">.textLabel</span>?<span class="hljs-variable">.text</span> = model<span class="hljs-variable">.name</span>        cell<span class="hljs-variable">.detailTextLabel</span>?<span class="hljs-variable">.text</span> = model<span class="hljs-variable">.age</span>    &#125;<span class="hljs-variable">.disposed</span>(by: self<span class="hljs-variable">.bag</span>)&#125;</code></pre><ul><li>延迟</li></ul><pre><code class="hljs swift"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewDidAppear</span><span class="hljs-params">(<span class="hljs-number">_</span> animated: Bool)</span></span> &#123; &#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>RxSwift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS: 常驻线程</title>
    <link href="/2020/06/12/0/"/>
    <url>/2020/06/12/0/</url>
    
    <content type="html"><![CDATA[<h2 id="如何开启"><a href="#如何开启" class="headerlink" title="如何开启"></a><center>如何开启</center></h2><p>首先开启一个线程：</p><pre><code class="hljs objectivec"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSThread</span> *thread;- (<span class="hljs-keyword">IBAction</span>)startAction:(<span class="hljs-keyword">id</span>)sender &#123;    <span class="hljs-built_in">NSThread</span> *thread = [[<span class="hljs-built_in">NSThread</span> alloc] initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(start) object:<span class="hljs-literal">nil</span>];    thread.name = <span class="hljs-string">@"com.live.thread"</span>;    <span class="hljs-comment">// 开启子线程</span>    [thread start];    <span class="hljs-keyword">self</span>.thread = thread;&#125;- (<span class="hljs-keyword">void</span>)start &#123;    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"start----%@"</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);&#125;- (<span class="hljs-keyword">IBAction</span>)taskAction:(<span class="hljs-keyword">id</span>)sender &#123;    <span class="hljs-comment">/*</span><span class="hljs-comment">     如果设置wait为YES:等待当前线程执行完以后，主线程才会执行aSelector方法；</span><span class="hljs-comment">     设置为NO：不等待当前线程执行完，就在主线程上执行aSelector方法。</span><span class="hljs-comment">     如果，当前线程就是主线程，那么aSelector方法会马上执行。</span><span class="hljs-comment">     */</span>    [<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(task) onThread:<span class="hljs-keyword">self</span>.thread withObject:<span class="hljs-literal">nil</span> waitUntilDone:<span class="hljs-literal">YES</span>];&#125;- (<span class="hljs-keyword">void</span>)task &#123;    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"task----%@"</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);&#125;</code></pre><p>根据代码可知，执行startAction，打印</p><blockquote><p>start—-&lt;NSThread: 0x280b84c40&gt;{number = 6, name = com.live.thread}</p></blockquote><p>我们知道一个线程执行完任务后就会自动销毁，再次调用此线程去执行任务即会报错：<br><img src="/img/0/0.png" srcset="/img/loading.gif" alt=""><br>所以我们一般启动Runloop来使线程常驻，修改代码如下：</p><pre><code class="hljs objectivec">- (<span class="hljs-keyword">void</span>)start &#123;    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"start----%@"</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);    <span class="hljs-keyword">@autoreleasepool</span> &#123;        <span class="hljs-keyword">do</span> &#123;            [[<span class="hljs-built_in">NSRunLoop</span> currentRunLoop] runUntilDate:[<span class="hljs-built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="hljs-number">1</span>]];        &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">YES</span>);    &#125;&#125;</code></pre><p>便可成功执行task：</p><blockquote><p>start—-&lt;NSThread: 0x2807d5300&gt;{number = 7, name = com.live.thread}</p></blockquote><blockquote><p>task—-&lt;NSThread: 0x2807d5300&gt;{number = 7, name = com.live.thread}</p></blockquote><h2 id="如何停止"><a href="#如何停止" class="headerlink" title="如何停止"></a><center>如何停止</center></h2><pre><code class="hljs objectivec"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-built_in">BOOL</span> cancelled;- (<span class="hljs-keyword">IBAction</span>)stopAction:(<span class="hljs-keyword">id</span>)sender &#123;    [<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(stop) onThread:<span class="hljs-keyword">self</span>.thread withObject:<span class="hljs-literal">nil</span> waitUntilDone:<span class="hljs-literal">NO</span>];    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"退出runLoop"</span>);&#125;- (<span class="hljs-keyword">void</span>)start &#123;    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"start----%@"</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);    <span class="hljs-keyword">@autoreleasepool</span> &#123;        <span class="hljs-keyword">do</span> &#123;            [[<span class="hljs-built_in">NSRunLoop</span> currentRunLoop] runUntilDate:[<span class="hljs-built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="hljs-number">1</span>]];        &#125; <span class="hljs-keyword">while</span> (!<span class="hljs-keyword">self</span>.cancelled);    &#125;&#125;- (<span class="hljs-keyword">void</span>)stop &#123;    <span class="hljs-keyword">self</span>.cancelled = <span class="hljs-literal">YES</span>;&#125;</code></pre><p>添加一个flag操控，执行stopAction后，再次操作task便又会报错，说明Runloop停止了</p>]]></content>
    
    
    
    <tags>
      
      <tag>NSRunLoop</tag>
      
      <tag>NSThread</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
